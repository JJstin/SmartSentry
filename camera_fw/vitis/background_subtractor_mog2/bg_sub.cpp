/*
 * Generated by Vitis IDE
 * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
 * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
 */

/**
 * @file xf_cv_subtract.cpp
 *
 * @brief Instantiation wrapper for xf_cv_subtract function generated on 14/07/2024, 23:59:19
 */

#include "core/xf_arithm.hpp"
#include "common/xf_common.hpp"
#include "common/xf_utility.hpp"

#include "bg_sub.hpp"

// static constexpr int __XF_DEPTH = (HEIGHT * WIDTH * (XF_PIXELWIDTH(IN_TYPE, NPPCX)) / 8) / (INPUT_PTR_WIDTH / 8);

    const Mat* src;
    Mat* dst;
    float weight;
    float variance;
    float* mean0;
    uchar* modesUsed0;

    int nmixtures;
    float alphaT, Tb, TB, Tg;
    float varInit, varMin, varMax, prune, tau;

    bool detectShadows;
    uchar shadowVal;

void bg_sub(ap_uint<INPUT_PTR_WIDTH>* src,
        ap_uint<INPUT_PTR_WIDTH>* dst,
        float gmm_weight,
        float gmm_variance,
        float* mean0,
        ap_uint<UCHAR_PTR_WIDTH>* modesUsed0,
        int nmixtures,
        float alphaT, float Tb, float TB, float Tg,
        float varInit, float varMin, float varMax, float prune, float tau,
        bool detectShadows,
        ap_uint<UCHAR_PTR_WIDTH> shadowVal
        ) {
    // TODO: add interface pragma(s) here
    // clang-format off
    #pragma HLS INTERFACE mode=m_axi port=src offset=slave bundle=gmem0 depth=__XF_DEPTH
    #pragma HLS INTERFACE mode=m_axi port=dst offset=slave bundle=gmem1 depth=__XF_DEPTH
    #pragma HLS INTERFACE mode=m_axi port=mean0 offset=slave bundle=gmem2 depth=__XF_DEPTH
    #pragma HLS INTERFACE s_axilite  port=return
    // clang-format on

    xf::cv::Mat< IN_TYPE, HEIGHT, WIDTH, NPPCX, XF_CV_DEPTH_IN> imgInput1(HEIGHT, WIDTH);
    xf::cv::Mat< IN_TYPE, HEIGHT, WIDTH, NPPCX, XF_CV_DEPTH_IN> imgInput2(HEIGHT, WIDTH);
    xf::cv::Mat< IN_TYPE, HEIGHT, WIDTH, NPPCX, XF_CV_DEPTH_IN> imgOutput(HEIGHT, WIDTH);

    // clang-format off
    #pragma HLS DATAFLOW
    // clang-format on
    xf::cv::Array2xfMat<INPUT_PTR_WIDTH, IN_TYPE, HEIGHT, WIDTH, NPPCX, XF_CV_DEPTH_IN>(img_in1, imgInput1);
    xf::cv::Array2xfMat<INPUT_PTR_WIDTH, IN_TYPE, HEIGHT, WIDTH, NPPCX, XF_CV_DEPTH_IN>(img_in2, imgInput2);
    
    xf::cv::subtract<XF_CONVERT_POLICY_SATURATE, IN_TYPE, HEIGHT, WIDTH, XF_NPPC1, XF_CV_DEPTH_IN, XF_CV_DEPTH_IN, XF_CV_DEPTH_OUT>(imgInput1, imgInput2, imgOutput);

    xf::cv::xfMat2Array<OUTPUT_PTR_WIDTH, OUT_TYPE, HEIGHT, WIDTH, NPPCX, XF_CV_DEPTH_OUT>(imgOutput, img_out);
    return;
}
